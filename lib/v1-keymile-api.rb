require 'net/ssh/telnet'

module Keymile
  JUMPSRV = '200.204.1.4'.freeze
  JUMPSRV_USER = 'r101521'.freeze
  JUMPSRV_PW = 'guerr@01'.freeze

  HOST_USERNAME = 'manager'.freeze
  HOST_PW = ''.freeze

  HOST_PROMPT = /\/[$%#>]/s
  LOGIN_PROMPT = /[Ll]ogin[: ]/
  PASSWORD_PROMPT = /[Pp]ass(?:word|phrase)[: ]/

  # Detection patterns's constants for Zhone MXK
  REGEX_ALARM = /\bsystem.+/
  REGEX_INTERFACE = /\b(?:Primary|Secondary).+\b/
  REGEX_CARDS = /\b\w+:.+/

  # Function <tt>create_ssh_session</tt> establishes ssh connection to jump server.
  # @return [Net::SSH] session
  def create_ssh_session
    Net::SSH.start(JUMPSRV, JUMPSRV_USER, password: JUMPSRV_PW, timeout: 20) # verbose: :info,
  end

  # Function <tt>disconnect</tt> closes the host session.
  # @return [boolean] value
  def close_ssh_session(session)
    session.close
    session = nil
    true
  end

  class Milegate
    attr_accessor :ssh_session

    def initialize(ssh_session)
      super()
      self.ssh_session = ssh_session
    end

    @telnet

    # Function <tt>connect</tt> establishes final host connection over ssh session.
    # @return [boolean] value
    def connect(host)
      sample = ''

      @telnet = Net::SSH::Telnet.new('Session' => ssh_session, 'Prompt' => LOGIN_PROMPT, 'Timeout' => 50)

      # sends telnet command
      @telnet.puts format('telnet %s', host)
      @telnet.waitfor('Match' => LOGIN_PROMPT) { |rcvdata| sample << rcvdata }

      # sends username
      @telnet.puts HOST_USERNAME
      @telnet.waitfor('Match' => PASSWORD_PROMPT) { |rcvdata| sample << rcvdata }

      # sends password and waits for cli prompt or login error phrase
      @telnet.puts HOST_PW
      @telnet.waitfor('Match' => HOST_PROMPT) { |rcvdata| sample << rcvdata }

      true
    end

    # Function <tt>disconnect</tt> closes the host session.
    # @return [boolean] value
    def disconnect
      @telnet.close
      true
    end

    # Function <tt>get_host_data</tt> executes low level commands over the connection
    # @return [array] value
    def get_low_level_data(cmd, regex, splitter_regex)
      sample = ''
      # sends cmd to host
      @telnet.puts(cmd) { |str| print str }

      # waits for cli prompt and stores returned data into sample variable
      @telnet.waitfor('Match' => HOST_PROMPT) { |rcvdata| sample << rcvdata }

      print "\n Return of low level command:\n #{sample}"

      sample.scan(regex)[0].split(splitter_regex)
    end

    # Function <tt>get_transceivers_detail</tt> gets transceivers detail
    # @return 1x6 [array] - port_1, Tx-Power_1, Rx-Power_1, port_2, Tx-Power_2, Rx-Power_2
    # ex.: ["1/25", "-4.2", "-13.0", "1/26", "-7.4", "-8.1"]
    def get_transceivers_detail
      cmd = 'sh hardware-status transceivers detail'
      regex = /((\w\/\w+)|-\d+\.\d+)/
      data_splitter = /\s+/

      get_low_level_data(cmd, regex, data_splitter)

    end

    # Function <tt>get_eaps_status</tt> gets eaps redundancy protocol status.
    # @return 1x8 [array] - ID, Domain, State, Mode, Port, Port, VLAN, Groups/VLANs
    # ex.: ["0", "gvt", "Complete", "M", "1/25", "1/26", "4094", "1/4093"]
    def get_eaps_status
      cmd = 'show eaps'
      regex = /\b\d\s.+/
      data_splitter = /\s+/

      get_low_level_data(cmd, regex, data_splitter)

    end
  end
end
